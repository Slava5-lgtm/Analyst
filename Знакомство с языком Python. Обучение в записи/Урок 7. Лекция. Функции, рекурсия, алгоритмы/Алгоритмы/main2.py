#                                                      Сортировка слиянием

def merge_sort(nums): # Создадим функцию (merge_sort) будем передовать туда значения (nums) 
    if len(nums) > 1: # И здесь проверяем если (if) длина (len) nums у нас > 1
        # То мы что то делаем, а имено делим список на 2. И сделаем это при помоши срезов
        mid = len(nums) // 2 # Создадим переменую (mid) будем брать от суда только целую часть это будит наша серединка 
        left  = nums[:mid]   # Первый список (left) у нас будет получаться путем обрашению к nums и мы будем брать только начало ():mid) тоесть левую часть
        right = nums[mid:]  # Создадим список где у нас будет хрониться правая часть (right)  обращаемся к нашему списку nums и мы идем от середины и до конц (mid:)
        # И нам нужно делить наши списки до конца пока ееостаниться по одному элементу. Мы это будем делать при помоши рекурсии
        merge_sort(left) # Создадим (merge_sort) в которй будем вызывать (left) это для левой части
        merge_sort(right)  # А это (merge_sort(right)) для правой
        # Теперь нам нужно все элементы соединить воидино 
        i = j = k = 0 # Создадим три переменых которые равняються 0
        # Создадим цикл (whle) в которую будем класть элементы но уже последовательно
        while i < len(left) and j < len(right): # И он будет выполняться до тех пор пок i будет < чем len(left) и одновремено с этим (and) пока переменая j < чем len(right)
            if left[i] < right[j]: # если (if) элемент из спика (left[i]) у нас < чем right[j] (тоесть у нас i для left, а j для right, k - уже для итогового списка)
                nums[k] = left[i] # тогда nums[k] = left[i]
                # Соотвествено мы уже проверили значения left[i]
                i += 1 # значит мы должны к нашей переменой i прибовляем еденицу
            else: # а иначе мы понимаем что правый элемент у нас блоьше
                nums[k] = right[j] # тогда мы говорим что nums[k] у нас равно right[j]
                j += 1 # и соотвествено также мы к j прибовляем еденицу
            k += 1 # И также после каждой итерации нашего цикла мы должы увеличиват нашу переменую (к) на еденицу. Для чего м это делаем, Что бы при каждой итерации у нас
                   # прибовлялось новое значения
                   
# А теперь представим такую ситуацию, что у нас все элементы из списка left больше чем все элементы из списка right. Соотвествено у нас все элементы из списка left добавились у нас
# сработало (i < len(left)) это ограничение и цикл while завершил свою работу но в правом списке еще остались значения мы просто их подрят должны добавить в сисок nums.
# Значит мы также должны написать условия, что пока у нас есть элемент в левом списке мы добовляем их в крнец либо когда у нас есть элементы в правом списке мы их также добовляем в
# конец. В любом случае у нас будит одно из двух либо в левом списке остались элементы либо в правом.
# Это происходит по тому, что мы написали условие (i < len(left) and j < len(right)), что мы идем в цикле while до тех пор. Пока в обоих списках есть какоето значения если хоть в
# одном списке значния закончились то ы соотвествено выходим из нашего цикла.

#                                                           Это и напишем

    while i < len(left): # Пока наша переменая i < len(left)
        nums[k] = left[i] # Мы говорим что nums[k] = left[i]
        i += 1 # Сотвествено к переменой (i) добовляем еденицу 
        k += 1 # И к переменой (k) добовляем еденицу

        #                                                   И тоже самое делаем для нашего правого списка

    while j < len(right):
        nums[k] = right[j]
        j += 1
        k += 1

# Попробуем запустить нашу фунцию 
list1 = [38, 27, 43, 3, 9, 82, 10]  # Создодим список list_1

merge_sort(list1) # Будим вызывать функцию (merge_sort) и передодим значения (list_1)
print(list1) # И будим выводить наш список



