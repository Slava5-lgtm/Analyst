Алгоритмом называется набор инструкций для выполнения некоторой задачи. В принципе, любой фрагмент программного кода можно назвать алгоритмом.

                                                            Быстрая сортировка

“Программирование это разбиение чего-то большого и невозможного на что-то маленькое и вполне реальное”

Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”. Сначала рассмотрим пример, затем напишем программный код Два друга решили поиграть в игру: один загадывает
число от 1 до 100, другой должен отгадать. Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60, 73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр,
который отгадывает. Итак начнем:

Иван загадал число 77.
Петр: Число больше 50? Иван: Да.
Петр: Число больше 75? Иван: Да.
Петр: Число больше 87? Иван: Нет.
Петр: Число больше 81? Иван: Нет.
Петр: Число больше 78? Иван: Нет.
Петр: Число больше 76? Иван: Да

Число оказалось в диапазоне 76 < x < 78, значит это число 77. Задача решена. На самом деле мы сейчас познакомились с алгоритмом бинарного поиска, который также принадлежит стратегии
“разделяй и властвуй”. Давайте перейдем к обсуждению программного кода быстрой сортировки.


def quick_sort(array):                                      Сначала создадим функцию и будем передовать массив (array)
    if len(array) <= 1:                                     И сразу будем делать проверку если (if) длина нашего массива (len(array)<=1)
        return array                                        То мы возврашяем этот массив
    else:                                                   А иначе мы будем выполнять какие небудь действия. У нас повторялись одни и тежи действия можество раз (то есть рекурсия)
         pivot = array[0]                                   Создаем переменую (pivot) в которой будем сохранять наш первый элемент array[0]
                                                            Теперь создадим два массива: 
    less = [i for i in array[1:] if i <= pivot]             В первый массив (less) будем записывать числа которые < нашего значения (array[0]) тоесть (pivot)
                                                            Будим класть знаения [(i)проходясь по циклу (for i in array[1:(: - воспользуемся срезами) мы будем проходиться по всему
                                                            элементам и добовлять только те которые будуд <= нашей переменой pivot ])]               
    greater = [i for i in array[1:] if i > pivot]           Во второй массив (greater) будем записывать числа который > нашего элемента
                                                            Будим класть знаения [(i)проходясь по циклу (for i in array[1:(: - воспользуемся срезами) мы будем проходиться по всему
                                                            элементам и добовлять только те которые будуд > нашей переменой pivot ])]
    # return quick_sort(less) + pivot + quick_sort(greater) Вызываем следущию рекурсию. У нас есть элемент (pivot) и два списка (less и greater). Элемент (pivot) будет находиться 
                                                            по серидине между этими списками по значеню. Могли бы записать (less + pivot + greater). Но списки (less и greater) не
                                                            орсортированы. Для них тоже будем вызывать функцию (quick_sort). Будем их сортировать (quick_sort(less) + pivot +
                                                            + quick_sort(greater)). И соотвествено при первом вызове нашей рекурсии у нас будет возврошяться два неорсортированых списка
                                                            (quick_sort(less) + quick_sort(greater)) и знчения (pivot) которое получено будет точно между этими списками
# print(quick_sort([10, 5, 2, ]))                          БУДЕТ ОШИБКА (TypeError: can only concatenate list (not "int") to list) так как нельзя складывать список и числа
                                                            (quick_sort(less)  quick_sort(greater)) - тип даных список (list), (pivot) - тип даных число (int) 
return quick_sort(less) + [pivot] + quick_sort(greater)     Здесь мы [pivot] преобразовываем в список (list)
print(quick_sort([10, 5, 2]))

                                                            Теперь разберем как работает наша рекурсия

● 1-е повторение рекурсии:      
○ array = [10, 5, 2]                                    При первв вызови рекурсии наш массив array имеет значения 10, 5, 2
○ pivot = 10                                            pivot мы берем как первое значения и поэтому 10

                                            И мы создаем два спискаless и greater

○ less = [5, 2]                                         здесь храним значения которые меньше первого элемента (меньше 10 это у нас 5 и 2)
○ greater = []                                          а здесь которые больше 10 поэтому он пустой
○ return quicksort([5, 2]) + [10] + quicksort([])       Мы вызываем нашу рекурсию (return) мы передоем (quicksort) знчения (less 5 и 2) + наш значения (pivot) который = 10  плюс
                                                        значения который больше значения (pivot) у нас передаеться здесь пустой список (quicksort([]))

● 2-е повторение рекурсии:                  
○ array = [5, 2]                                     Мы передаем в (array) значения 5 и 2
○ pivot = 5                                          pivot у нас имеет значения 5 первый элемент
○ less = [2]                                         Соотвествено меньше 5 у нас только 2
○ greater = []
○ return quicksort([2]) + [5] + quicksort([])        Мы вызываем нашу рекурсию (return) мы передоем (quicksort) знчения (less 2) + наш значения (pivot) который = 5  плюс значения
                                                     который больше значения (pivot) у нас передаеться здесь пустой список (quicksort([])) Важно! Не забывайте, что здесь помимо
                                                     вызова рекурсии добавляется список [10]

● 3-е повторение рекурсии:
○ array = [2]                                        Мы передаем в (array) только одно значения 2
○ return [2]                                         Сработал базовый случай рекурсии
На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2] + [5] + [10] = [2, 5, 10]